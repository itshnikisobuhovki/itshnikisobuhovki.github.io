
import asyncio
import logging
from config import TOKEN_API
import json
from aiogram import Bot, Dispatcher, types, Router, F
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import Message, InputMediaPhoto, InlineKeyboardMarkup, InlineKeyboardButton, KeyboardButton, ReplyKeyboardMarkup, WebAppInfo
from aiogram.filters.callback_data import CallbackData

router = Router()
bot = None  # Глобальная переменная для бота

async def main():
    global bot
    bot = Bot(token=TOKEN_API)
    dp = Dispatcher()
    dp.include_router(router)
    await dp.start_polling(bot)


CHANNEL_ID = '@neruhomistinUA'  # ID или имя канала
post_ids = {}  # Храним ID постов для удаления


class RealEstateForm(StatesGroup):
    # waiting_for_phone = State()
    waiting_for_photos = State()
    publish_ad = State()


class PostCallback(CallbackData, prefix="post"):
    action: str
    ad_id: str  # Уникальный идентификатор объявления


class RemoveCallback(CallbackData, prefix="remove"):
    action: str
    ad_id: str  # Уникальный идентификатор объявления для удаления



# # Кнопка для запроса номера телефона
# request_phone_keyboard = ReplyKeyboardMarkup(
#     keyboard=[[KeyboardButton(text="Поділитися номером телефону", request_contact=True)]],
#     resize_keyboard=True,
#     input_field_placeholder="тисніть кнопку, щоб поділитися телефоном"
# )

# Кнопка для перехода в веб-приложение
web_app_keyboard = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(
        text='Створити оголошення',
        web_app=WebAppInfo(url='https://itshnikisobuhovki.github.io/IO3bot/index.html')
        # web_app=WebAppInfo(url='https://tbot.herokku.com')
    )]],
    resize_keyboard=True,
    input_field_placeholder="тисніть кнопку"
)


# Обработчик команды /start
@router.message(CommandStart())
async def get_info(message: Message, state: FSMContext):
    # Получаем текущее состояние FSM
    current_state = await state.get_state()

    # Если состояние не начальное (например, ожидание фото), сбрасываем его
    if current_state:
        await state.clear()  # Сбрасываем текущее состояние
        # await message.answer("Попереднє оголошення було скасоване. Можете створити нове.")

    # Показываем кнопку для создания нового объявления всегда
    reply = await message.answer('Натисніть кнопку нижче "Cтворити оголошення"', reply_markup=web_app_keyboard)

    # Сохраняем ID сообщения для последующего удаления
    await save_message_id(message.chat.id, reply.message_id, state)

    # Обновляем состояние флага, что предыдущее объявление опубликовано
    await state.update_data(is_published=True)


# Обработчик данных из веб-приложения
@router.message(F.web_app_data)
async def web_app(message: Message, state: FSMContext):
    res = json.loads(message.web_app_data.data)

    commission = res['commission']
    commission_text = commission if commission == "без комісії" else f"{commission}%"

    await state.update_data(
        adress=res['adress'],
        district_type=res['district_type'],
        currency_type=res['currency_type'],
        price=res['price'],
        commission=commission_text,
        name=res['name'],
        phone=res['phone'],
        transaction_type=res['transaction_type'],
        property_type=res['property_type'],
        user_description=res['user_description'],
        area=res.get('area', 'N/A'),  # Добавляем поле площадь помещений
        land_area=res.get('land_area', 'N/A'),  # Добавляем поле площадь помещений
        number_room=res.get('number_room', 'N/A'),  # Добавляем поле количество комнат
        floor=res.get('floor', 'N/A'),  # Добавляем поле этаж
        storeys=res.get('storeys', 'N/A'),
        photos=[],
        message_ids=[],  # Для хранения message_id
        warning_message_ids=[],  # Для хранения warning message_ids
        is_published=False  # Устанавливаем флаг, что объявление не опубликовано
    )

    reply = await message.answer("Будь ласка, завантажте від 1 до 8 фото об'єкта.",
                                 reply_markup=types.ReplyKeyboardRemove())
    await save_message_id(message.chat.id, reply.message_id, state)

    await state.set_state(RealEstateForm.waiting_for_photos)


# Сохраняем message_id
async def save_message_id(chat_id: int, message_id: int, state: FSMContext):
    data = await state.get_data()
    message_ids = data.get('message_ids', [])
    message_ids.append(message_id)
    await state.update_data(message_ids=message_ids)


# Обработчик загрузки фото
@router.message(RealEstateForm.waiting_for_photos, F.photo | F.document)
async def handle_photo(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos', [])

    await save_message_id(message.chat.id, message.message_id, state)

    if len(photos) >= 8:
        reply = await message.answer("Максимум 8 фотографій.")
        await save_message_id(message.chat.id, reply.message_id, state)
        await finalize(message, state)
        return

    # Проверяем, загружено ли фото или документ
    if message.photo:
        # Фото загружено корректно
        photos.append(message.photo[-1].file_id)
        await state.update_data(photos=photos)

        reply = await message.answer(
            f"Фото {len(photos)} додано. Завантажте ще (всього має бути не більше 8 фото) або тисніть -> /done.")
        await save_message_id(message.chat.id, reply.message_id, state)

    elif message.document and message.document.mime_type.startswith('image/'):
        # Пользователь загрузил документ, а не фото
        warning_reply = await message.answer(
            "Ви завантажили зображення як документ. Будь ласка, завантажуйте стиснені зображення у форматі фотографій, а не документів."
        )

        # Сохраняем ID предупреждающего сообщения
        warning_message_ids = data.get('warning_message_ids', [])
        warning_message_ids.append(warning_reply.message_id)
        await state.update_data(warning_message_ids=warning_message_ids)

    else:
        await message.answer("Невірний формат файлу. Будь ласка, завантажте фото.")


# Завершение с /done
@router.message(RealEstateForm.waiting_for_photos, F.text.contains("/done"))
async def done_command(message: Message, state: FSMContext):
    data = await state.get_data()

    # Проверяем, обрабатывается ли уже объявление
    if data.get('is_processing', False):
        await message.answer("Ваше оголошення вже обробляється. Будь ласка, зачекайте.")
        return

    # Устанавливаем флаг, чтобы указать, что объявление обрабатывается
    await state.update_data(is_processing=True)

    await save_message_id(message.chat.id, message.message_id, state)
    await finalize(message, state)


# Финализация и переход в состояние публикации
async def finalize(message: Message, state: FSMContext):
    data = await state.get_data()
    message_ids = data.get('message_ids', [])
    warning_message_ids = data.get('warning_message_ids', [])

    # Удаляем все предупреждающие сообщения
    for warning_message_id in warning_message_ids:
        try:
            await bot.delete_message(chat_id=message.chat.id, message_id=warning_message_id)
        except Exception as e:
            print(f"Помилка при видаленні повідомлення-попередження: {e}")

    # Удаляем все предыдущие сообщения
    for message_id in message_ids:
        try:
            await bot.delete_message(chat_id=message.chat.id, message_id=message_id)
        except Exception as e:
            print(f"Помилка при видаленні оголошення: {e}")

    if data['property_type'] == '_квартиру':
        text = (
            f"{data['transaction_type']}_{data['number_room']}кімнатну{data['property_type']}\n"
            f"Адреса: {data['adress']}\n"
            f"Район: {data['district_type']}\n"
            f"Опис: {data['user_description']}\n"
        )
    else:
        text = (
            f"{data['transaction_type']}{data['property_type']}\n"
            f"Адреса: {data['adress']}\n"
            f"Район: {data['district_type']}\n"
        )

    if data.get('user_description') and data['user_description'] != "N/A":
        text += f"Опис: {data['user_description']}\n"

    if data.get('area') and data['area'] != "N/A":
        text += f"Загальна площа приміщень: {data['area']}м кв.\n"

    if data.get('land_area') and data['land_area'] != "N/A":
        text += f"Площа земельної ділянки: {data['land_area']}м кв.\n"

    if data.get('number_room') and data['number_room'] != "N/A":
        text += f"Кількість кімнат: {data['number_room']}\n"

    if data.get('floor') and data['floor'] != "N/A":
        text += f"Поверх: {data['floor']}\n"

    if data.get('storeys') and data['storeys'] != "N/A":
        text += f"Кількість поверхів у будівлі: {data['storeys']}\n"

    text += (
        f"Ціна: {data['price']} {data['currency_type']}\n"
        f"Комісія: {data['commission']}\n"
        f"{data['name']} {data['phone']}\n"
    )

    media_group = []
    first_photo = InputMediaPhoto(media=data['photos'][0], caption=text)
    media_group.append(first_photo)

    for photo in data['photos'][1:]:
        media_group.append(InputMediaPhoto(media=photo))

    # Создаем инлайн-кнопку для публикации с уникальным идентификатором объявления
    ad_id = str(message.message_id)  # Используем уникальный ID для объявления
    inline_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="Розмістити оголошення у каналі @victoryestateua",
                                 callback_data=PostCallback(action="publish", ad_id=ad_id).pack()),
        ],
        [
            InlineKeyboardButton(text="Створити оголошення заново",
                                 callback_data=PostCallback(action="redo", ad_id=ad_id).pack())
        ]
    ])

    # Отправляем сообщения с медиа-группой
    reply = await message.answer_media_group(media_group)
    await message.answer(
        "Перевірте своє оголошення, якщо все ок - розмістіть його у каналі. Якщо знайшли помилку - створіть оголошення заново",
        reply_markup=inline_keyboard)

    # Reset the processing flag after finalization
    await state.update_data(is_processing=False)

    # Переход к состоянию публикации
    await state.set_state(RealEstateForm.publish_ad)


# Обработчик нажатия на кнопку "Розмістити оголошення заново"
@router.callback_query(PostCallback.filter(F.action == "redo"))
async def redo_ad(callback: types.CallbackQuery, state: FSMContext, callback_data: PostCallback):
    # Изменяем текст сообщения и удаляем кнопки
    await callback.message.edit_text("Оголошення має помилки і не буде опубліковано.", reply_markup=None)

    # Очищаем состояние FSM
    await state.clear()

    # Возвращаем пользователя к началу
    await get_info(callback.message, state)

    # Уведомляем пользователя о перезапуске
    await callback.answer("Ви можете створити нове оголошення.")


# Сохраняем все ID сообщений группы медиа при публикации
@router.callback_query(PostCallback.filter())
async def post_to_channel(callback: types.CallbackQuery, state: FSMContext, callback_data: PostCallback):
    data = await state.get_data()

    # Проверяем, обрабатывается ли уже объявление
    if data.get('is_processing', False):
        await callback.answer("Ваше оголошення вже обробляється. Будь ласка, зачекайте.")
        return

    # Устанавливаем флаг, чтобы указать, что объявление обрабатывается
    await state.update_data(is_processing=True)

    if data['property_type'] == '_квартиру':
        text = (
            f"{data['transaction_type']}_{data['number_room']}кімнатну{data['property_type']}\n"
            f"Адреса: {data['adress']}\n"
            f"Район: {data['district_type']}\n"
            f"Опис: {data['user_description']}\n"
        )
    else:
        text = (
            f"{data['transaction_type']}{data['property_type']}\n"
            f"Адреса: {data['adress']}\n"
            f"Район: {data['district_type']}\n"
        )
        
    if data.get('user_description') and data['user_description'] != "N/A":
        text += f"Опис: {data['user_description']}\n"

    if data.get('area') and data['area'] != "N/A":
        text += f"Загальна площа приміщень: {data['area']}м кв.\n"

    if data.get('land_area') and data['land_area'] != "N/A":
        text += f"Площа земельної ділянки: {data['land_area']}м кв.\n"

    if data.get('number_room') and data['number_room'] != "N/A":
        text += f"Кількість кімнат: {data['number_room']}\n"

    if data.get('floor') and data['floor'] != "N/A":
        text += f"Поверх: {data['floor']}\n"

    if data.get('storeys') and data['storeys'] != "N/A":
        text += f"Кількість поверхів у будівлі: {data['storeys']}\n"

    text += (
        f"Ціна: {data['price']} {data['currency_type']}\n"
        f"Комісія: {data['commission']}\n"
        f"{data['name']} {data['phone']}\n"
    )

    media_group = []
    first_photo = InputMediaPhoto(media=data['photos'][0], caption=text)
    media_group.append(first_photo)

    for photo in data['photos'][1:]:
        media_group.append(InputMediaPhoto(media=photo))

    # Отправляем пост в канал
    sent_messages = await bot.send_media_group(CHANNEL_ID, media_group)

    # Используем callback_data.ad_id, чтобы получить id объявления
    ad_id = callback_data.ad_id

    # Сохраняем все ID сообщений группы медиа с уникальным идентификатором
    post_ids[ad_id] = {
        "message_ids": [message.message_id for message in sent_messages]
    }

    # Создаем кнопку для удаления объявления
    remove_button = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Видалити оголошення з каналу",
                              callback_data=RemoveCallback(action="delete", ad_id=ad_id).pack())],
    ])

    # Проверяем, изменился ли текст сообщения
    current_text = callback.message.text
    if current_text != "Оголошення розміщено":
        await callback.message.edit_text("Оголошення розміщено", reply_markup=remove_button)

    # Возвращаем кнопку "Створити оголошення"
    await state.update_data(is_published=True)  # Обновляем флаг на True
    await callback.message.answer('Створіть нове оголошення', reply_markup=web_app_keyboard)

    # Сбрасываем флаг обработки после завершения
    await state.update_data(is_processing=False)
# Обработчик удаления объявления из канала
@router.callback_query(RemoveCallback.filter())
async def remove_post(callback: types.CallbackQuery, state: FSMContext, callback_data: RemoveCallback):
    ad_id = callback_data.ad_id

    # Получаем ID сообщения для удаления
    message_ids = post_ids.get(ad_id, {}).get("message_ids", [])

    # Удаляем сообщения из канала
    for message_id in message_ids:
        try:
            await bot.delete_message(CHANNEL_ID, message_id)
        except Exception as e:
            print(f"Ошибка при удалении сообщения: {e}")

    await callback.answer("Оголошення видалено.")
    await callback.message.edit_text("Оголошення видалено.", reply_markup=None)




if __name__ == '__main__':
    # logging.basicConfig(level=logging.INFO)
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Exit")
